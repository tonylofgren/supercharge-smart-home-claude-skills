#!/usr/bin/env python3
"""
ESPHome Configuration Validator
===============================
Validates ESPHome YAML configurations for common errors.

Usage:
    python validate_esphome.py config.yaml
    python validate_esphome.py --full config.yaml    # Use esphome CLI
    python validate_esphome.py --dir ./configs/      # Validate directory

Generated by esphome@aurora-smart-home
https://github.com/tonylofgren/aurora-smart-home
"""

import argparse
import re
import sys
from pathlib import Path
from typing import List, Tuple

try:
    import yaml
except ImportError:
    print("PyYAML not installed. Run: pip install pyyaml")
    sys.exit(1)


# ESP32 strapping pins - should be used with caution
STRAPPING_PINS_ESP32 = {
    0: "Boot mode (pull-up for normal boot)",
    2: "Boot mode (must be LOW or floating)",
    5: "SDIO timing",
    12: "MTDI - Boot voltage (pull-down for 3.3V flash)",
    15: "MTDO - Silence boot messages",
}

STRAPPING_PINS_ESP8266 = {
    0: "Boot mode (pull-up for normal boot)",
    2: "Boot mode (must be HIGH at boot)",
    15: "Boot mode (must be LOW at boot)",
}

# Pins that don't exist or are input-only
INVALID_PINS_ESP32 = {
    6, 7, 8, 9, 10, 11,  # Connected to flash
    20, 24, 28, 29, 30, 31,  # Don't exist on most boards
}

INPUT_ONLY_ESP32 = {34, 35, 36, 39}  # No internal pull-up/down

# Common board configurations
BOARDS = {
    "esp32dev": {"chip": "esp32", "flash": "4MB"},
    "esp32-s3-devkitc-1": {"chip": "esp32s3", "flash": "8MB"},
    "esp32-c3-devkitm-1": {"chip": "esp32c3", "flash": "4MB"},
    "d1_mini": {"chip": "esp8266", "flash": "4MB"},
    "nodemcuv2": {"chip": "esp8266", "flash": "4MB"},
}


class ValidationResult:
    """Holds validation results."""

    def __init__(self, file_path: str):
        self.file_path = file_path
        self.errors: List[str] = []
        self.warnings: List[str] = []
        self.info: List[str] = []

    def add_error(self, msg: str):
        self.errors.append(f"❌ ERROR: {msg}")

    def add_warning(self, msg: str):
        self.warnings.append(f"⚠️  WARNING: {msg}")

    def add_info(self, msg: str):
        self.info.append(f"ℹ️  INFO: {msg}")

    def is_valid(self) -> bool:
        return len(self.errors) == 0

    def print_results(self):
        print(f"\n{'=' * 60}")
        print(f"Validation: {self.file_path}")
        print("=" * 60)

        for msg in self.errors:
            print(msg)
        for msg in self.warnings:
            print(msg)
        for msg in self.info:
            print(msg)

        if self.is_valid():
            print(f"\n✅ PASSED with {len(self.warnings)} warnings")
        else:
            print(f"\n❌ FAILED with {len(self.errors)} errors, {len(self.warnings)} warnings")


def load_yaml_file(file_path: Path) -> Tuple[dict, str]:
    """Load YAML file and return content and raw text."""
    try:
        raw_text = file_path.read_text(encoding="utf-8")
        # Handle !secret and other ESPHome tags
        yaml.add_constructor("!secret", lambda l, n: f"!secret {n.value}", Loader=yaml.SafeLoader)
        yaml.add_constructor("!include", lambda l, n: f"!include {n.value}", Loader=yaml.SafeLoader)
        yaml.add_constructor("!lambda", lambda l, n: f"!lambda ...", Loader=yaml.SafeLoader)
        content = yaml.safe_load(raw_text)
        return content, raw_text
    except yaml.YAMLError as e:
        return None, str(e)


def extract_gpio_pins(config: dict) -> List[Tuple[int, str]]:
    """Extract all GPIO pin references from config."""
    pins = []

    def find_pins(obj, path=""):
        if isinstance(obj, dict):
            for key, value in obj.items():
                if key in ("pin", "number", "clk_pin", "mosi_pin", "miso_pin", "cs_pin",
                          "sda", "scl", "tx_pin", "rx_pin", "data_pin", "clock_pin",
                          "trigger_pin", "echo_pin", "dout_pin"):
                    if isinstance(value, str) and value.startswith("GPIO"):
                        try:
                            pin_num = int(value.replace("GPIO", ""))
                            pins.append((pin_num, f"{path}.{key}"))
                        except ValueError:
                            pass
                    elif isinstance(value, int):
                        pins.append((value, f"{path}.{key}"))
                    elif isinstance(value, dict) and "number" in value:
                        num = value["number"]
                        if isinstance(num, str) and num.startswith("GPIO"):
                            try:
                                pin_num = int(num.replace("GPIO", ""))
                                pins.append((pin_num, f"{path}.{key}"))
                            except ValueError:
                                pass
                find_pins(value, f"{path}.{key}")
        elif isinstance(obj, list):
            for i, item in enumerate(obj):
                find_pins(item, f"{path}[{i}]")

    find_pins(config)
    return pins


def validate_config(file_path: Path) -> ValidationResult:
    """Validate an ESPHome configuration file."""
    result = ValidationResult(str(file_path))

    # Load YAML
    config, raw_text = load_yaml_file(file_path)
    if config is None:
        result.add_error(f"YAML parse error: {raw_text}")
        return result

    # Check for esphome section
    if "esphome" not in config:
        result.add_error("Missing 'esphome' section")
        return result

    # Check for device name
    esphome = config.get("esphome", {})
    if "name" not in esphome:
        result.add_error("Missing device name in 'esphome' section")

    # Determine chip type
    chip = None
    if "esp32" in config:
        chip = "esp32"
        board = config["esp32"].get("board", "unknown")
        if board in BOARDS:
            chip = BOARDS[board]["chip"]
    elif "esp8266" in config:
        chip = "esp8266"

    if chip is None:
        result.add_warning("Could not determine chip type (esp32/esp8266 section missing)")

    # Check WiFi
    if "wifi" not in config:
        result.add_warning("No 'wifi' section - device won't connect to network")
    else:
        wifi = config["wifi"]
        if "ssid" not in wifi and "networks" not in wifi:
            result.add_warning("No WiFi SSID configured")
        # Check for !secret usage
        if "ssid" in wifi and not str(wifi["ssid"]).startswith("!secret"):
            result.add_warning("WiFi SSID is hardcoded - consider using !secret")
        if "password" in wifi and not str(wifi["password"]).startswith("!secret"):
            result.add_warning("WiFi password is hardcoded - consider using !secret")

    # Check API
    if "api" not in config:
        result.add_info("No 'api' section - won't integrate with Home Assistant")
    else:
        api = config["api"]
        if "encryption" not in api and "password" not in api:
            result.add_warning("API has no encryption or password - insecure!")

    # Check OTA
    if "ota" not in config:
        result.add_info("No 'ota' section - can't update over-the-air")

    # Check GPIO pins
    pins = extract_gpio_pins(config)
    used_pins = set()

    for pin_num, location in pins:
        # Check for duplicate pins
        if pin_num in used_pins:
            result.add_error(f"GPIO{pin_num} used multiple times (at {location})")
        used_pins.add(pin_num)

        # Check strapping pins
        if chip == "esp32" and pin_num in STRAPPING_PINS_ESP32:
            result.add_warning(
                f"GPIO{pin_num} is a strapping pin: {STRAPPING_PINS_ESP32[pin_num]} (at {location})"
            )
        elif chip == "esp8266" and pin_num in STRAPPING_PINS_ESP8266:
            result.add_warning(
                f"GPIO{pin_num} is a strapping pin: {STRAPPING_PINS_ESP8266[pin_num]} (at {location})"
            )

        # Check invalid pins
        if chip == "esp32" and pin_num in INVALID_PINS_ESP32:
            result.add_error(f"GPIO{pin_num} is invalid/reserved on ESP32 (at {location})")

        # Check input-only pins used as output
        if chip == "esp32" and pin_num in INPUT_ONLY_ESP32:
            # Check if used as output
            if any(x in location.lower() for x in ["output", "switch", "relay", "led"]):
                result.add_error(
                    f"GPIO{pin_num} is input-only on ESP32, cannot be used as output (at {location})"
                )

    # Check update intervals
    sensors = config.get("sensor", [])
    if isinstance(sensors, list):
        for sensor in sensors:
            if isinstance(sensor, dict):
                interval = sensor.get("update_interval", "60s")
                if isinstance(interval, str):
                    # Parse interval
                    match = re.match(r"(\d+)(ms|s|min|h)?", interval)
                    if match:
                        value, unit = match.groups()
                        value = int(value)
                        if unit == "ms" and value < 100:
                            result.add_warning(
                                f"Very fast update interval ({interval}) may cause instability"
                            )

    # Check for attribution header
    if "aurora-smart-home" not in raw_text and "Generated by" not in raw_text:
        result.add_info("No attribution header found")

    return result


def run_esphome_validate(file_path: Path) -> Tuple[bool, str]:
    """Run esphome config validation."""
    import subprocess

    try:
        result = subprocess.run(
            ["esphome", "config", str(file_path)],
            capture_output=True,
            text=True,
            timeout=60,
        )
        return result.returncode == 0, result.stderr or result.stdout
    except FileNotFoundError:
        return False, "esphome CLI not found. Install with: pip install esphome"
    except subprocess.TimeoutExpired:
        return False, "Validation timed out"


def main():
    parser = argparse.ArgumentParser(
        description="Validate ESPHome configuration files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    python validate_esphome.py config.yaml
    python validate_esphome.py --full config.yaml
    python validate_esphome.py --dir ./esphome/
        """,
    )

    parser.add_argument("files", nargs="*", help="YAML files to validate")
    parser.add_argument("--dir", "-d", help="Directory containing YAML files")
    parser.add_argument(
        "--full", "-f", action="store_true", help="Run full validation with esphome CLI"
    )
    parser.add_argument("--quiet", "-q", action="store_true", help="Only show errors")

    args = parser.parse_args()

    files_to_validate = []

    if args.dir:
        dir_path = Path(args.dir)
        if not dir_path.is_dir():
            print(f"Error: {args.dir} is not a directory")
            sys.exit(1)
        files_to_validate.extend(dir_path.glob("*.yaml"))
        files_to_validate.extend(dir_path.glob("*.yml"))

    for f in args.files or []:
        path = Path(f)
        if path.is_file():
            files_to_validate.append(path)
        else:
            print(f"Warning: {f} not found")

    if not files_to_validate:
        parser.print_help()
        sys.exit(1)

    # Filter out secrets.yaml
    files_to_validate = [f for f in files_to_validate if "secret" not in f.name.lower()]

    all_valid = True

    for file_path in files_to_validate:
        result = validate_config(file_path)

        if args.full:
            ok, output = run_esphome_validate(file_path)
            if not ok:
                result.add_error(f"ESPHome validation failed:\n{output}")

        if not args.quiet or not result.is_valid():
            result.print_results()

        if not result.is_valid():
            all_valid = False

    print(f"\n{'=' * 60}")
    print(f"Validated {len(files_to_validate)} file(s)")
    if all_valid:
        print("✅ All files passed validation")
    else:
        print("❌ Some files have errors")
        sys.exit(1)


if __name__ == "__main__":
    main()
